## Objective

Create your first Continuous Integration (CI) pipeline.

## Observe your first CI pipeline

Here you should just sit and observe.

1. Go to the GitHub page of the repository you created in the last challenges
2. Click on the `Actions` tab, which is the GitHub name for Continuous Integration and Continuous Deployment (CI-CD) `actions`
3. Click on your latest commit, you should see that GitHub executed your CI pipeline for you

ğŸ’¡ How did that happen ?
ğŸ‘‰ `packgenlite` created for you a file under `.github/workflows/pythonpackage.yml` at the root of your package, similar to this one:

```yaml
name: Python package

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:

  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Say hello
      run: |
        echo "Hello, World!"
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v1
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    - name: Install package and test
      run: |
        make install test clean

    strategy:
      matrix:
        python-version: [3.8]
```

This file is a configuration file that is detected and used by GitHub in order to perform CI-CD whenever a new commit is pushed.

[YAML](https://en.wikipedia.org/wiki/YAML) is a text file format similar to JSON that allows us to store structured data. It is typically used for configuration files.

The default `pythonpackage.yml` configuration file generated by `packgenlite` has the tests validation step commented out by default. But you may uncomment it if you wrote some tests. If you do so, pay attention to the indentation of the data. Similarly to the Python way of coding, the indentation of the keys in a YAML file indicates to which context they belong. You may verify that the syntax of the uncommented YAML remains correct using a [YAML validation tool](https://codebeautify.org/yaml-validator).

Example of a correct indentation (in python we would say that this YAML represents a dictionary containing a `jobs` key containing a dictionary containing a `build` key associated to the value `"hello"`):

``` yaml
jobs:
  build: hello
```

Example of incorrect indentation (this YAML represents a dictionary containing two `jobs` and `build` keys. But the `jobs` key is not associated with any value and will probably trigger an error in GitHub CI-CD action):

``` yaml
jobs:
build: hello
```

With this file:
 ğŸ‘‰ Every time you push a modification to your `master` (or `main`) branch in your GitHub repository, the CI pipeline above will execute the following steps:
- Get a Docker image with Ubuntu installed (`runs-on: ubuntu-latest` : we will talk more about Docker in the coming days, for now you can think of it as GitHub generating a full environment in which to run the Continuous Integration steps each time you push new code)
- Say `Hello` to the World (`echo "Hello, World!"`)
- Configure the Python version to 3.8 (`python-version: ${{ matrix.python-version }}`)
- Upgrade pip (`python -m pip install --upgrade pip`)
- Install the requirements listed in your package (`pip install -r requirements.txt`)
- Run your tests using `make install test clean`, meaning:
  => install your package
  => run the tests
  => clean temporary files once the tests are done

ğŸš¨ The Continuous Integration will stop at the first failing step

Once your have implemented tests for the functionalities of your package, having them run automatically on GitHub instead of your own machine is extremely convenient ğŸ‘

**NB: Here we setup the CI part of the CI/CD lifecycle of a software, we can easily imagine that once GitHub passed all the tests, you want to deploy your code somewhere ğŸ‘‰ you will see that in the next challenge**
